<html>
<head>
</head>
<body style="background: transparent;">
    <script src="scripts/docstrap.lib.js"></script>
    <script src="scripts/lunr.min.js"></script>
    <script src="scripts/fulltext-search.js"></script>

    <script type="text/x-docstrap-searchdb">
    {"lib_loadJson.js.html":{"id":"lib_loadJson.js.html","title":"Source: lib/loadJson.js","body":" GlaceJS Utils Modules glace-utilslib/loggerlib/small Classes LOGglace-utils.GlaceErrorQueue Tutorials Release Notes Global loadJson Source: lib/loadJson.js &quot;use strict&quot;; /** * Loads json file which may have comments. * * If json file has key `__parent` with path to parent json * it will be loaded and merged recursively. * * @function loadJson * @arg {string} name - Name of JSON file. * @return {object} - Object. * @throws {Error} If JSON file isn't parsable. * @throws {Error} If there is circular parent reference. */ var fs = require(&quot;fs&quot;); var path = require(&quot;path&quot;); var _ = require(&quot;lodash&quot;); var json = require(&quot;comment-json&quot;); module.exports = name =&gt; { var alreadyLoaded = []; var cwd = process.cwd(); var load = name =&gt; { if (!name.endsWith(&quot;.json&quot;)) name += &quot;.json&quot;; var jsonPath = path.resolve(cwd, name); if (alreadyLoaded.includes(jsonPath)) { throw new Error( `Circular reference detected, '${jsonPath}' is loaded already`); } alreadyLoaded.push(jsonPath); try { var result = json.parse( fs.readFileSync(jsonPath).toString(), null, true); } catch (e) { throw new Error(`Can't parse ${jsonPath}. ${e}`); } if (result.__parent) { var parent = load(result.__parent); result = _.merge(parent, result); } delete result.__parent; return result; }; return load(name); }; × Search results Close "},"lib_pool.js.html":{"id":"lib_pool.js.html","title":"Source: lib/pool.js","body":" GlaceJS Utils Modules glace-utilslib/loggerlib/small Classes LOGglace-utils.GlaceErrorQueue Tutorials Release Notes Global loadJson Source: lib/pool.js &quot;use strict&quot;; /** * Pool of Queues. * * @class * @arg {number} count - Number of queues. * @throws {AssertionError} - If queues count is not above 0. */ var LOG = require(&quot;./logger&quot;); var gid = 0; /** * Tasks queue. * * @class */ var Queue = function (id) { this.id = id || ++gid; this.weight = 0; this._p = Promise.resolve(); }; /** * Adds task to queue. * * @method * @arg {number} weight - Task weight. * @arg {function} task - Task. */ Queue.prototype.add = function (weight, task) { this.weight += weight; this._p = this._p .then(() =&gt; { LOG.silly(`Queue #${this.id}: task is started.`); return task(); }).catch(e =&gt; LOG.error(e)) .then(() =&gt; { this.weight -= weight; LOG.silly(`Queue #${this.id}: task is finished.`); }); }; var Pool = function (count) { count = count || 1; this._qq = []; for (var i = 0; i &lt; count; i++) { this._qq.push(new Queue(i+1)); }; }; /** * Addes task to the least loaded queue. * * @method * @arg {number} weight - Task weight. * @arg {function} task - Task. */ Pool.prototype.add = function (weight, task) { if (typeof(weight) === &quot;function&quot;) { task = weight; weight = 1; } var queue = this._qq[0]; for (var q of this._qq) { if (queue.weight === 0) break; if (q.weight &lt; queue.weight) queue = q; }; queue.add(weight, task); }; module.exports = Pool; × Search results Close "},"index.js.html":{"id":"index.js.html","title":"Source: index.js","body":" GlaceJS Utils Modules glace-utilslib/loggerlib/small Classes LOGglace-utils.GlaceErrorQueue Tutorials Release Notes Global loadJson Source: index.js /** * `GlaceJS` utils. * * @module glace-utils */ var fs = require(&quot;fs&quot;); var path = require(&quot;path&quot;); var readline = require(&quot;readline&quot;); var util = require(&quot;util&quot;); var colors = require(&quot;colors&quot;); var espree = require(&quot;espree&quot;); var highlight = require(&quot;cli-highlight&quot;).highlight; var _ = require(&quot;lodash&quot;); var yargs = require(&quot;yargs&quot;).help(&quot; &quot;); // disable default `--help` capture module.exports.__findProcess = require(&quot;find-process&quot;); var fse = require(&quot;fs-extra&quot;); /** * Clears empty folders recursive. * * @function * @arg {string} folder - Path to root folder. */ var clearEmptyFolders = module.exports.clearEmptyFolders = folder =&gt; { var files = fs.readdirSync(folder); for (var fileName of files) { var filePath = path.join(folder, fileName); if (fs.statSync(filePath).isDirectory()) { clearEmptyFolders(filePath); } } if (!_.isEmpty(files)) { files = fs.readdirSync(folder); } if (_.isEmpty(files)) { fs.rmdirSync(folder); } }; /** * Makes delay (sleep) during code execution. * * @function * @arg {number} timeout - Time to sleep, ms. * @arg {boolean} [blocking=false] - Flag whether sleep should be * block code execution. * @return {Promise&lt;void&gt;} If sleep isn't blocking. * @return {undefined} If sleep is blocking. */ module.exports.sleep = (timeout, blocking) =&gt; { blocking = !!blocking; if (blocking) { (ms =&gt; { ms += new Date().getTime(); while (new Date() &lt; ms) { /* nothing */ } })(timeout); } else { return new Promise(resolve =&gt; { setTimeout(resolve, timeout); }); } }; /** * Composes file path from segments. If folder of file is absent, it will * be created. * * @function * @arg {...string} paths - A sequence of paths or path segments. * @return {string} Composed path. */ module.exports.mkpath = function () { var result = path.resolve.apply(path, arguments); var dirname = path.dirname(result); fse.mkdirsSync(dirname); return result; }; /** * Helper to generate request key for storage. * * @function * @arg {Request} req - Client request. * @return {string} Request key according to its method, host, url. */ module.exports.getReqKey = req =&gt; req.method + &quot;_&quot; + req.headers.host + req.url; /** * Sorts files by date in folder. * * @function * @arg {string} dir - Path to directory. * @arg {object} [opts] - Options. * @arg {boolean} [opts.desc=false] - Flag to reverse order. * @return {string[]} Sequence of files sorted by date */ module.exports.filesByDate = (dir, opts) =&gt; { opts = opts || {}; opts.desc = opts.desc || false; var filesList = fs .readdirSync(dir) .filter(filename =&gt; { var filePath = path.resolve(dir, filename); return !fs.statSync(filePath).isDirectory(); }) .map(filename =&gt; { var filePath = path.resolve(dir, filename); return { path: filePath, time: fs.statSync(filePath).mtime.getTime() }; }) .sort((a, b) =&gt; a.time - b.time) .map(el =&gt; el.path); if (opts.desc) filesList.reverse(); return filesList; }; /** * Files sorted by order. * * @function * @arg {string} dir - Path to directory. * @arg {object} [opts] - Options. * @arg {boolean} [opts.desc=false] - Flag to reverse order. * @return {string[]} Sequence of files sorted by order. */ module.exports.filesByOrder = (dir, opts) =&gt; { opts = opts || {}; opts.desc = opts.desc || false; var filesList = fs .readdirSync(dir) .filter(filename =&gt; { var filePath = path.resolve(dir, filename); return !fs.statSync(filePath).isDirectory(); }) .map(filename =&gt; { return { path: path.resolve(dir, filename), number: parseInt(_.split(filename, &quot;-&quot;, 1)[0]) || 0 }; }) .sort((a, b) =&gt; a.number - b.number) .map(el =&gt; el.path); if (opts.desc) filesList.reverse(); return filesList; }; /** * Gets subfolders of directory. * * @function * @arg {string} dir - Path to directory. * @arg {object} [opts] - Options. * @arg {boolean} [opts.nameOnly=false] - Gets only folder names. By default, * full paths. * @return {string[]} Sequence of results. */ module.exports.subFolders = (dir, opts) =&gt; { opts = opts || {}; opts.nameOnly = opts.nameOnly || false; if (!fs.existsSync(dir)) return []; var dirsList = fs .readdirSync(dir) .filter(filename =&gt; { var filePath = path.resolve(dir, filename); return fs.statSync(filePath).isDirectory(); }); if (!opts.nameOnly) { dirsList = dirsList.map(name =&gt; path.resolve(dir, name)); } return dirsList; }; /** * Returns function which switches message color. * * @function * @arg {object} [opts] - Options. * @arg {string} [opts.c1=magenta] - Color #1. * @arg {string} [opts.c2=cyan] - Color #2. * @return {function} Function to switch color of passed text in terminal. */ const switchColor = module.exports.switchColor = opts =&gt; { opts = opts || {}; var c1 = opts.c1 || &quot;magenta&quot;; var c2 = opts.c2 || &quot;cyan&quot;; var trigger = true; return function () { var msg = Array.from(arguments).join(&quot; &quot;); msg = msg[trigger ? c1 : c2].bold; trigger = !trigger; return msg; }; }; /** * Exits process with error printing. * * @function * @arg {string} source - Source of fatal error. * @return {function} Function with takes error to print and exits process. */ module.exports.exit = source =&gt; err =&gt; { console.log(source + &quot;:&quot;, err); process.exit(1); }; /** * @prop {string} cwd - Current work directory. */ module.exports.cwd = process.cwd(); module.exports.loadJson = require(&quot;./lib/loadJson&quot;); module.exports.config = require(&quot;./lib/config&quot;); module.exports.logger = require(&quot;./lib/logger&quot;); /** * Wraps function inside other functions. * * @function * @arg {function[]} wrappers - List of functions which will wrap target. * @arg {function} target - Target function which will be wrapped. * @return {function} Wrapping function. */ module.exports.wrap = (wrappers, target) =&gt; { _.clone(wrappers).reverse().forEach(wrapper =&gt; { target = (target =&gt; () =&gt; wrapper(target))(target); }); return target; }; /** * Helper to kill processes by name. * * @async * @function * @arg {string} procName - Process name or chunk of name. * @return {Promise&lt;void&gt;} */ module.exports.killProcs = procName =&gt; { var logger = I.logger; logger.debug(`Looking for ${procName} processes to kill...`); return I.__findProcess(&quot;name&quot;, procName).then(procList =&gt; { return procList.forEach(proc =&gt; { if ([process.pid, process.ppid].includes(+proc.pid)) return; logger.debug(`Killing ${procName} with PID ${proc.pid}...`); try { process.kill(proc.pid, &quot;SIGTERM&quot;); logger.debug(&quot;Process is killed&quot;); } catch (e) { if (e.message !== &quot;kill ESRCH&quot;) throw e; logger.error(`Can't kill ${procName} with PID ${proc.pid} because it doesn't exist`); } }); }); }; /** * Help * * @function * @arg {function} [d] - Function to manage describe message: join, colorize, etc. * @return {yargs} Preconfigured yargs. */ module.exports.help = d =&gt; { d = d || switchColor(); return yargs .options({ &quot;config [path]&quot;: { alias: &quot;c&quot;, describe: d(&quot;Path to JSON file with CLI arguments.&quot;, &quot;Default is 'cwd/config.json' (if it exists).&quot;), type: &quot;string&quot;, group: &quot;Arguments:&quot;, }, &quot;stdout-log&quot;: { describe: d(&quot;Print log messages to stdout.&quot;), type: &quot;boolean&quot;, group: &quot;Log:&quot;, }, &quot;log [path]&quot;: { describe: d(&quot;Path to log file. Default is 'cwd/glace.log'.&quot;), type: &quot;string&quot;, group: &quot;Log:&quot;, }, &quot;log-level [level]&quot;: { describe: d(&quot;Log level. Supported values are 'error', 'warn',&quot;, &quot;'info', 'verbose', 'debug', 'silly'. Default is 'debug'.&quot;), type: &quot;string&quot;, group: &quot;Log:&quot;, }, }) .help(&quot;h&quot;) .alias(&quot;h&quot;, &quot;help&quot;); }; /** * Defines whether object is located on screen or no. * * @function * @arg {object} obj - Object which may be on screen. * @arg {object} screen - Screen object. * @arg {object} [opts] - Options. * @arg {boolean} [opts.fully=false] - Flag to check full presence on screen. * @return {boolean} `true` if it is on screen, `false` otherwise. */ module.exports.isInScreen = (obj, screen, opts) =&gt; { opts = I.coalesce(opts, {}); var fully = I.coalesce(opts.fully, false); if (fully) { return ((obj.x &gt;= screen.x) &amp;&amp; (obj.y &gt;= screen.y) &amp;&amp; (obj.x + obj.width &lt;= screen.x + screen.width) &amp;&amp; (obj.y + obj.height &lt;= screen.y + screen.height)); } else { return !((obj.x &gt;= screen.x + screen.width) || (obj.y &gt;= screen.y + screen.height) || (obj.x + obj.width &lt;= screen.x) || (obj.y + obj.height &lt;= screen.y)); } }; /** * Gets object position on screen. * * @function * @arg {object} obj - Object which should be on screen. * @arg {object} screen - Screen object. * @return {object} Object position on screen. * @throws {Error} If object isn't located on screen. */ module.exports.objOnScreenPos = (obj, screen) =&gt; { if (!I.isInScreen(obj, screen)) { throw new Error( `Object { x: ${obj.x}, y: ${obj.y}, width: ${obj.width}, ` + `height: ${obj.height} } isn't on screen { x: ${screen.x}, ` + `y: ${screen.y}, width: ${screen.width}, height: ${screen.height} }`); } var res = _.clone(obj); if (res.x &lt; screen.x) res.x = screen.x; if (res.y &lt; screen.y) res.y = screen.y; if (res.x + res.width &gt; screen.x + screen.width) { res.width = screen.x + screen.width - res.x; } if (res.y + res.height &gt; screen.y + screen.height) { res.height = screen.y + screen.height - res.y; } return res; }; /** * Transforms string to kebab case. Replace all symbols, except numbers, * chars and dots with dashes. * * @function * @arg {string} str - String to transform. * @return {string} Transformed string. */ module.exports.toKebab = str =&gt; { return str .trim() .toLowerCase() .replace(/[^A-Za-z0-9_.]+/g, &quot;-&quot;) .replace(/-\\./g, &quot;.&quot;) .replace(/-_/g, &quot;_&quot;) .replace(/-$/g, &quot;&quot;) .replace(/^-/g, &quot;&quot;); }; /** * Waits for predicate returns truly value. * * @async * @function * @arg {function} predicate - Function which should return truly value during * timeout. * @arg {object} [opts] - Options. * @arg {number} [opts.timeout=1] - Time to wait for predicate result, sec. * @arg {number} [opts.polling=0.1] - Time to poll predicate result, sec. * @return {Promise&lt;boolean&gt;} `false` if predicate didn't return truly value * during expected time. * @return {Promise&lt;object&gt;} Predicate truly value. */ module.exports.waitFor = async (predicate, opts) =&gt; { opts = I.coalesce(opts, {}); var timeout = I.coalesce(opts.timeout, 1) * 1000; var polling = I.coalesce(opts.polling, 0.1) * 1000; var limit = new Date().getTime() + timeout; while(limit &gt; new Date().getTime()) { var result = await predicate(); if (result) return result; await I.sleep(polling); } return false; }; /** * Waits during a time that predicate returns truly value. * * @async * @function * @arg {function} predicate - Function which should return truly value during * timeout. * @arg {object} [opts] - Options. * @arg {number} [opts.timeout=1] - Time to wait predicate result, sec. * @arg {number} [opts.polling=0.1] - Time to poll predicate result, sec. * @return {Promise&lt;boolean&gt;} `false` if predicate didn't return truly value * during expected time. * @return {Promise&lt;object&gt;} Predicate truly value. */ module.exports.waitDuring = async (predicate, opts) =&gt; { opts = I.coalesce(opts, {}); var timeout = I.coalesce(opts.timeout, 1) * 1000; var polling = I.coalesce(opts.polling, 0.1) * 1000; var limit = new Date().getTime() + timeout; while(limit &gt; new Date().getTime()) { var result = await predicate(); if (!result) return false; await I.sleep(polling); } return result; }; var complete = line =&gt; { line = colors.strip(line); var tokens = line.split(/[^A-Za-z0-9._$]+/).filter(i =&gt; i); if (!tokens.length) return [[], line]; var targetToken = tokens[tokens.length - 1]; var namespace = global; var filterPrefix = targetToken; var targetObject; if (targetToken.includes(&quot;.&quot;)) { targetObject = targetToken.split(&quot;.&quot;); filterPrefix = targetObject.pop(); targetObject = targetObject.join(&quot;.&quot;); if (!targetObject) return [[], targetToken]; try { namespace = eval(targetObject); } catch (e) { return [[], targetToken]; } } try { var completions = []; for (var key in namespace) { completions.push(key); } completions = _.union( completions, Object.getOwnPropertyNames(namespace), Object.getOwnPropertyNames(Object.getPrototypeOf(namespace)) ).sort() .filter(i =&gt; i.startsWith(filterPrefix)) .filter(i =&gt; /^(\\w|\\$)+$/.test(i)) .filter(i =&gt; /^\\D/.test(i)); } catch (e) { return [[], targetToken]; } if (targetObject) { completions = completions.map(i =&gt; targetObject + &quot;.&quot; + i); } return [completions, targetToken]; }; /** * Interactive debugger with syntax highlighting and autocomplete. * * &lt;img src=&quot;./debug_example.gif&quot; title=&quot;Debug example&quot; /&gt; * * @async * @function * @arg {string} [helpMessage] - Help message. * @return {Promise} */ module.exports.debug = async function (helpMessage) { const defaultHelp = &quot;In interactive mode you can execute any nodejs code.\\n&quot; + &quot;Also next commands are available:\\n&quot;; helpMessage = helpMessage || defaultHelp; helpMessage += &quot;- h, help - show interactive mode help;\\n&quot; + &quot;- go - continue code execution;\\n&quot; + &quot;- exit - finish current nodejs process;&quot;; console.log(&quot;interactive mode&quot;.yellow); var rl = readline.createInterface({ input: process.stdin, output: process.stdout, completer: complete, }); var ttyWrite = rl._ttyWrite; rl._ttyWrite = function (s, key) { if (this.cursor &lt;= this.line.length) { this.line = colors.strip(this.line); if (this.cursor &gt; this.line.length) { this._moveCursor(+Infinity); } } ttyWrite.call(this, s, key); if (this.cursor &lt; this.line.length) { this.line = colors.strip(this.line); if (this.cursor &gt; this.line.length) { this._moveCursor(+Infinity); } } else { this.line = highlight(colors.strip(this.line), { language: &quot;js&quot; }); this._moveCursor(+Infinity); } if (key.name !== &quot;return&quot;) { this._refreshLine(); } }; var origGlobals = {}; var isFinished = false; while (!isFinished) { isFinished = await new Promise(resolve =&gt; { rl.question(&quot;&gt; &quot;.red, answer =&gt; { answer = colors.strip(answer); if (answer === &quot;exit&quot;) { console.log(&quot;emergency exit&quot;.red); process.exit(1); } if (answer === &quot;go&quot;) { console.log(&quot;continue execution&quot;.green); resolve(true); return; } if ([&quot;help&quot;, &quot;h&quot;].includes(answer)) { console.log(helpMessage); resolve(false); return; } var ast, varName; try { ast = espree.parse(answer, { ecmaVersion: 9 }); varName = ast.body[0].expression.left.name; } catch (e) { try { varName = ast.body[0].declarations[0].id.name; } catch (e) { /* nothing */ } } Promise .resolve() .then(() =&gt; { var result = eval(answer); if (varName) { if (!Object.prototype.hasOwnProperty.call(origGlobals, varName)) { origGlobals[varName] = global[varName]; } global[varName] = eval(varName); } return result; }) .then(result =&gt; console.log(util.format(result).yellow)) .catch(e =&gt; console.log(util.format(e).red)) .then(() =&gt; resolve(false)); }); }); } for (var [k, v] of Object.entries(origGlobals)) { global[k] = v; } }; /** * Activates docstring support for js functions. * * @function */ module.exports.docString = () =&gt; { if (Object.prototype.hasOwnProperty.call(Function.prototype, &quot;__doc__&quot;)) return; require(&quot;docstring&quot;); Function.prototype.bond = function (ctx) { var result = this.bind(ctx); Object.defineProperty(result, &quot;__doc__&quot;, { value: this.__doc__, writable: false, }); return result; }; }; /** * `Glace` fixtures factory. * * Provides easy way to make a fixture with hooks related with shared context. * * @function * @arg {object} [opts] - Options. * @arg {function} [opts.before] - Callback of `before` hook. * @arg {function} [opts.after] - Callback of `after` hook. * @arg {function} [opts.beforeChunk] - Callback of `beforeChunk` hook. * @arg {function} [opts.afterChunk] - Callback of `afterChunk` hook. * @return {function} - Fixture. */ module.exports.makeFixture = (opts = {}) =&gt; { return func =&gt; { const ctx = {}; if (opts.before) before(opts.before(ctx)); if (opts.beforeChunk) beforeChunk(opts.beforeChunk(ctx)); func(); if (opts.afterChunk) afterChunk(opts.afterChunk(ctx)); if (opts.after) after(opts.after(ctx)); }; }; Object.assign(exports, require(&quot;./lib/small&quot;)); module.exports.download = require(&quot;./lib/download&quot;); module.exports.Pool = require(&quot;./lib/pool&quot;); const I = module.exports; × Search results Close "},"lib_small.js.html":{"id":"lib_small.js.html","title":"Source: lib/small.js","body":" GlaceJS Utils Modules glace-utilslib/loggerlib/small Classes LOGglace-utils.GlaceErrorQueue Tutorials Release Notes Global loadJson Source: lib/small.js /** * Functions &amp; classes, which content is trivial or|and doesn't require * complex implementation (&lt;10 SLOC mostly). * * @module */ const os = require(&quot;os&quot;); const util = require(&quot;util&quot;); const _ = require(&quot;lodash&quot;); const BaseError = require(&quot;es6-error&quot;); /** * Creates a new instance of `glacejs` error. * * @memberOf module:glace-utils * @class * @classdesc A base class for exceptions and errors, which are raised by * `glacejs` framework or its plugins. Any `glacejs` exception should be * inherited from this class for good style. * @arg {string} message - Error message. */ const GlaceError = function (message) { BaseError.call(this, message); }; util.inherits(GlaceError, BaseError); /** * @memberOf module:glace-utils * @property {string} hostname - Host name of machine where `glacejs` framework is * launched. Despite of machine hostname can be changed during script execution * the probability that hostname will be changed during tests execution is low. * That's why it's kept as property and in low case, because hostname is case * insensitive. */ const hostname = os.hostname().toLowerCase(); /** * Pick default value for variable among listed values. * * @memberOf module:glace-utils * @function * @arg {...*} values - Sequence of variable values. * @return {*} First defined value or `null` if no one is defined. * * @example * U.coalesce(); // null * U.coalesce(undefined); // null * U.coalesce(undefined, 1); // 1 * U.coalesce(undefined, 1, 2); // 1 * U.coalesce(null, 1); // null */ const coalesce = function () { for (const arg of arguments) if (typeof arg !== &quot;undefined&quot;) return arg; return null; }; /** * Capitalizes the first letter of a string. It doesn't influence to case * of other letters. * * @memberOf module:glace-utils * @function * @arg {string} string - String to capitalize. * @return {string} Capitalized string. * * @example * U.capitalize('hello'); // 'Hello' * U.capitalize('Hello'); // 'Hello' * U.capitalize('hEllo'); // 'HEllo' */ const capitalize = string =&gt; { return string.charAt(0).toUpperCase() + string.slice(1); }; /** * Creates each to each combinations of sets. * * @memberOf module:glace-utils * @function * @arg {Array&lt;Array&gt;} l - Array of arrays to combine. * @arg {?function} [p] - Function to process element before adding to combination. * It passes two arguments: * `e` - a new element to add; * `c` - assembling combination; * By default it just pushes `e` to `c`. * @return {Array&lt;Array&gt;} List of combinations. * * @example * each2each([[1, 2], [3, 4]]); // [[1, 3], [1, 4], [2, 3], [2, 4]] * each2each([[1, 2], [3, 4]], e =&gt; e + 1); // [[2, 4], [2, 5], [3, 4], [3, 5]] * each2each([[1, 2], [3, 4]], (e, c) =&gt; e + _.sum(c)); // [[1, 4], [1, 5], [2, 5], [2, 6]] */ const each2each = (l, p = e =&gt; e) =&gt; { let r = [[]]; for (const i of l) { const t = []; for (const j of r) { for (const e of i) { const c = _.clone(j); c.push(p(e, c)); t.push(c); } } r = t; } return r; }; /** * Splits string to array by delimiter. * * @memberOf module:glace-utils * @function * @arg {string} s - String to split. * @arg {char} d - String delimiter. * @return {array&lt;string&gt;} * * @example * U.splitBy(&quot;a, b, c&quot;, &quot;,&quot;); // ['a', 'b', 'c'] */ const splitBy = (s, d) =&gt; _.filter(_.map(s.split(d), e =&gt; e.trim())); /** * Checks if text contains words or no. * * @memberOf module:glace-utils * @function * @arg {string} string - Original text. * @arg {string} words - Checking words. * @return {boolean} - `true` if text contains words, `false` otherwise. * * @example * U.textContains(&quot;hello world&quot;, &quot;hello world&quot;); // true */ const textContains = (text, words) =&gt; { if (!text) return false; if (!words) return true; text = text.toLowerCase(); words = words.toLowerCase().split(/ +/g); return _.isEmpty(missedWords(text, words, true)); }; /** * Detects words if they are missed in text (case-sensitive). * * @memberOf module:glace-utils * @function * @arg {string} text - Text where words are looked for. * @arg {string[]} words - Filtered words. * @arg {boolean} [firstMissedOnly=false] - Flag to return first missed word only. * It reduces searching time and recommended to use if not need to get all missed words. * @returns {string[]} - Array of missed words. * * @example * U.missedWords(&quot;hello world&quot;, [&quot;hello&quot;, &quot;man&quot;]); // [&quot;man&quot;] */ const missedWords = (text, words, firstMissedOnly = false) =&gt; { if (!text || _.isEmpty(words)) { if (firstMissedOnly &amp;&amp; !_.isEmpty(words)) { return words.slice(0, 1); } else { return words; } } const missed = []; for (const word of words) { if (text.includes(word)) continue; if (firstMissedOnly) return [word]; missed.push(word); } return missed; }; module.exports = { GlaceError, hostname, coalesce, capitalize, each2each, splitBy, textContains, missedWords, }; × Search results Close "},"lib_download.js.html":{"id":"lib_download.js.html","title":"Source: lib/download.js","body":" GlaceJS Utils Modules glace-utilslib/loggerlib/small Classes LOGglace-utils.GlaceErrorQueue Tutorials Release Notes Global loadJson Source: lib/download.js &quot;use strict&quot;; /** * Downloads files. * * @memberOf module:index * @function download * @arg {string[]} urls - List of URLs to download. * @arg {object} opts - Options. * @arg {string} [opts.dir] - Folder to download. Omitted if `paths` is specified. * @arg {string[]} [opts.paths] - List of paths to download. Corresponds to amount of `urls` list. * @arg {number} [opts.attempts=1] - Number of attempts to download. * @arg {number} [opts.threads=1] - Number of threads to download. * @arg {number} [opts.polling=100] - Number of ms to check downloading state. * @arg {number} [opts.timeout=60000] - Number of ms for socket timeout. * @return {Promise&lt;object&gt;} Object `{downloaded: {&quot;http(s)://url&quot;: &quot;/path/to/file&quot;, ...}, failed: [&quot;http(s)://url&quot;, ...]}`. */ var fs = require(&quot;fs&quot;); var http = require(&quot;http&quot;); var https = require(&quot;https&quot;); var path = require(&quot;path&quot;); var url = require(&quot;url&quot;); const util = require(&quot;util&quot;); var _ = require(&quot;lodash&quot;); var LOG = require(&quot;./logger&quot;); var Pool = require(&quot;./pool&quot;); var downloadFile = (fileUrl, filePath, timeout) =&gt; { LOG.silly(`Downloading '${fileUrl}' to '${filePath}' ...`); return new Promise((resolve, reject) =&gt; { var file = fs.createWriteStream(filePath); var mode = fileUrl.startsWith(&quot;https&quot;) ? https : http; var req = mode.get(fileUrl, response =&gt; { if (response.statusCode !== 200) { file.destroy(); reject(new Error(`Response ${response.statusCode} - ${response.statusMessage}`)); return; } response.pipe(file); file.on(&quot;finish&quot;, () =&gt; { LOG.silly(`Downloaded '${fileUrl}' to '${filePath}'`); file.close(resolve); }).once(&quot;error&quot;, err =&gt; { file.destroy(); reject(err); }); }); req.setTimeout(timeout, () =&gt; { req.destroy(); file.destroy(); reject(new Error(&quot;socket timeout&quot;)); }).once(&quot;error&quot;, err =&gt; { file.destroy(); reject(err); }); }); }; var rmEl = (el, arr) =&gt; { arr.splice(arr.indexOf(el), 1); }; var downloadAttempt = (pool, _url, _path, urls, passed, failed, attempts, timeout) =&gt; () =&gt; { return downloadFile(_url, _path, timeout).then(() =&gt; { rmEl(_url, urls); passed[_url] = _path; }).catch(err =&gt; { LOG.silly(util.format(`Failed to download '${_url}' to '${_path}'`, err)); if (fs.existsSync(_path)) fs.unlinkSync(_path); failed[_url] = (failed[_url] || 0) + 1; rmEl(_url, urls); if (failed[_url] &lt; attempts) { LOG.silly(`Retry to download '${_url}' to '${_path}'`); urls.push(_url); pool.add(downloadAttempt(pool, _url, _path, urls, passed, failed, attempts, timeout)); }; }); }; var download = async (urls, opts) =&gt; { opts = opts || {}; var dir = opts.dir; var paths = opts.paths; if (!dir &amp;&amp; !paths) { throw new Error(&quot;Option 'dir' or 'paths' should be provided&quot;); } if (paths &amp;&amp; paths.length !== urls.length) { throw new Error(`Length of 'paths' should be ${urls.length}`); } var attempts = opts.attempts || 1; var threads = opts.threads || 1; var polling = opts.polling || 100; var timeout = opts.timeout || 60000; var pool = new Pool(threads); var passed = {}, failed = {}; urls = _.clone(urls); for (var i = 0; i &lt; urls.length; i++) { var _url = urls[i]; if (paths) { var _path = paths[i]; } else { _path = path.resolve(dir, path.posix.basename(url.parse(_url).pathname)); } pool.add(downloadAttempt(pool, _url, _path, urls, passed, failed, attempts, timeout)); }; await new Promise(resolve =&gt; { var timerId = setInterval(() =&gt; { if (urls.length) return; clearInterval(timerId); resolve(); }, polling); }); var notDownloaded = []; for (var [key, val] of Object.entries(failed)) { if (val &lt; attempts) continue; notDownloaded.push(key); }; return { downloaded: passed, failed: notDownloaded, }; }; module.exports = download; × Search results Close "},"lib_config.js.html":{"id":"lib_config.js.html","title":"Source: lib/config.js","body":" GlaceJS Utils Modules glace-utilslib/loggerlib/small Classes LOGglace-utils.GlaceErrorQueue Tutorials Release Notes Global loadJson Source: lib/config.js &quot;use strict&quot;; /** * GlaceJS config. * * @ignore * @module */ var fs = require(&quot;fs&quot;); var path = require(&quot;path&quot;); var _ = require(&quot;lodash&quot;); var argv = require(&quot;yargs&quot;).argv; var loadJson = require(&quot;./loadJson&quot;); var config; if (global.__glaceConfig) { config = global.__glaceConfig; } else { /** * @prop {object} config - `GlaceJS` config. */ config = global.__glaceConfig = {}; var argsConfig = {}; var argsConfigPath = path.resolve(process.cwd(), (argv.c || argv.config || &quot;config.json&quot;)); if (fs.existsSync(argsConfigPath)) { argsConfig = loadJson(argsConfigPath); for (var key in argsConfig) { var val = argsConfig[key]; argsConfig[_.camelCase(key)] = val; } } _.mergeWith(argsConfig, argv, (objVal, srcVal) =&gt; srcVal ? srcVal : objVal); config.args = argsConfig; } module.exports = config; × Search results Close "},"lib_logger.js.html":{"id":"lib_logger.js.html","title":"Source: lib/logger.js","body":" GlaceJS Utils Modules glace-utilslib/loggerlib/small Classes LOGglace-utils.GlaceErrorQueue Tutorials Release Notes Global loadJson Source: lib/logger.js &quot;use strict&quot;; /** * GlaceJS logger. * * @module */ var fs = require(&quot;fs&quot;); var path = require(&quot;path&quot;); var fse = require(&quot;fs-extra&quot;); var winston = require(&quot;winston&quot;); var config = require(&quot;./config&quot;); var cwd = process.cwd(); var logger; if (global.__glaceLogger) { logger = global.__glaceLogger; } else { /** * @prop {Logger} logger - `GlaceJS` logger. */ logger = global.__glaceLogger = winston.createLogger({ level: config.args.logLevel || &quot;debug&quot;, format: winston.format.combine( winston.format.timestamp(), winston.format.printf(info =&gt; { return `${info.timestamp} ${info.level}: ${info.message}`; }), ), }); logger.add(new winston.transports.File({ filename: path.resolve(cwd, config.args.log || &quot;glace.log&quot;), })); if (config.args.stdoutLog) { logger.add(new winston.transports.Console()); } /** * Sets log file to logger. * * @function * @arg {string} logFile - Name or path of log file. */ logger.setFile = logFile =&gt; { var logPath = path.resolve(cwd, logFile); if (!logPath.endsWith(&quot;.log&quot;)) logPath += &quot;.log&quot;; fse.mkdirsSync(path.dirname(logPath)); if (logger._file) logger.remove(logger._file); logger._file = new winston.transports.File({ filename: logPath }); logger.add(logger._file); }; /** * Gets log file. * * @function * @return {?string} Path to log file or `null`. */ logger.getFile = () =&gt; { if (!logger._file) return null; return path.resolve(logger._file.dirname, logger._file.filename); }; /** * Resets log file. * * @function */ logger.resetFile = () =&gt; { var logPath = logger.getFile(); if (!logPath) return; fs.unlinkSync(logPath); logger.setFile(logPath); }; } module.exports = logger; × Search results Close "},"global.html":{"id":"global.html","title":"Global","body":" GlaceJS Utils Modules glace-utilslib/loggerlib/small Classes LOGglace-utils.GlaceErrorQueue Tutorials Release Notes Global loadJson Global Methods loadJson(name) Loads json file which may have comments. If json file has key __parent with path to parent json it will be loaded and merged recursively. Parameters: Name Type Description name string Name of JSON file. Source: lib/loadJson.js, line 3 Throws: If JSON file isn't parsable. Type Error If there is circular parent reference. Type Error Returns: Object. Type object × Search results Close "},"modules.list.html":{"id":"modules.list.html","title":"Modules","body":" GlaceJS Utils Modules glace-utilslib/loggerlib/small Classes LOGglace-utils.GlaceErrorQueue Tutorials Release Notes Global loadJson Modules Classes LOG GlaceError Queue × Search results Close "},"classes.list.html":{"id":"classes.list.html","title":"Classes","body":" GlaceJS Utils Modules glace-utilslib/loggerlib/small Classes LOGglace-utils.GlaceErrorQueue Tutorials Release Notes Global loadJson Classes Classes LOG GlaceError Queue × Search results Close "},"tutorials.list.html":{"id":"tutorials.list.html","title":"Tutorials","body":" GlaceJS Utils Modules glace-utilslib/loggerlib/small Classes LOGglace-utils.GlaceErrorQueue Tutorials Release Notes Global loadJson Tutorials Classes LOG GlaceError Queue × Search results Close "},"index.html":{"id":"index.html","title":"Index","body":" GlaceJS Utils Modules glace-utilslib/loggerlib/small Classes LOGglace-utils.GlaceErrorQueue Tutorials Release Notes Global loadJson | Source Code | Release Notes GlaceJS utilities is a set of functions and objects used for glace platform. Full list and description is here. How to install npm i glace-utils How to use const U = require(&quot;glace-utils&quot;); U.splitBy(&quot;a, b, c,&quot;, &quot;,&quot;); // [ 'a', 'b', 'c' ] API is here Tests and quality Project tests report is here Code coverage report is here × Search results Close "},"LOG.html":{"id":"LOG.html","title":"Class: LOG","body":" GlaceJS Utils Modules glace-utilslib/loggerlib/small Classes LOGglace-utils.GlaceErrorQueue Tutorials Release Notes Global loadJson Class: LOG LOG new LOG(count) Pool of Queues. Parameters: Name Type Description count number Number of queues. Source: lib/pool.js, line 11 Throws: If queues count is not above 0. Type AssertionError × Search results Close "},"module-glace-utils.html":{"id":"module-glace-utils.html","title":"Module: glace-utils","body":" GlaceJS Utils Modules glace-utilslib/loggerlib/small Classes LOGglace-utils.GlaceErrorQueue Tutorials Release Notes Global loadJson Module: glace-utils GlaceJS utils. Source: index.js, line 1 Classes GlaceError Members &lt;static&gt; cwd Properties: Name Type Description cwd string Current work directory. Source: index.js, line 211 &lt;static, constant&gt; hostname Properties: Name Type Description hostname string Host name of machine where glacejs framework is launched. Despite of machine hostname can be changed during script execution the probability that hostname will be changed during tests execution is low. That's why it's kept as property and in low case, because hostname is case insensitive. Source: lib/small.js, line 37 Methods &lt;static&gt; capitalize(string) Capitalizes the first letter of a string. It doesn't influence to case of other letters. Parameters: Name Type Description string string String to capitalize. Source: lib/small.js, line 75 Returns: Capitalized string. Type string Example U.capitalize('hello'); // 'Hello' U.capitalize('Hello'); // 'Hello' U.capitalize('hEllo'); // 'HEllo' &lt;static&gt; coalesce(values) Pick default value for variable among listed values. Parameters: Name Type Argument Description values * &lt;repeatable&gt; Sequence of variable values. Source: lib/small.js, line 54 Returns: First defined value or null if no one is defined. Type * Example U.coalesce(); // null U.coalesce(undefined); // null U.coalesce(undefined, 1); // 1 U.coalesce(undefined, 1, 2); // 1 U.coalesce(null, 1); // null &lt;async, static&gt; debug( [helpMessage]) Interactive debugger with syntax highlighting and autocomplete. Parameters: Name Type Argument Description helpMessage string &lt;optional&gt; Help message. Source: index.js, line 494 Returns: Type Promise &lt;static&gt; docString() Activates docstring support for js functions. Source: index.js, line 603 &lt;static&gt; each2each(l [, p]) Creates each to each combinations of sets. Parameters: Name Type Argument Description l Array.&lt;Array&gt; Array of arrays to combine. p function &lt;optional&gt; &lt;nullable&gt; Function to process element before adding to combination. It passes two arguments: e - a new element to add; c - assembling combination; By default it just pushes e to c. Source: lib/small.js, line 97 Returns: List of combinations. Type Array.&lt;Array&gt; Example each2each([[1, 2], [3, 4]]); // [[1, 3], [1, 4], [2, 3], [2, 4]] each2each([[1, 2], [3, 4]], e =&gt; e + 1); // [[2, 4], [2, 5], [3, 4], [3, 5]] each2each([[1, 2], [3, 4]], (e, c) =&gt; e + _.sum(c)); // [[1, 4], [1, 5], [2, 5], [2, 6]] &lt;static&gt; exit(source) Exits process with error printing. Parameters: Name Type Description source string Source of fatal error. Source: index.js, line 204 Returns: Function with takes error to print and exits process. Type function &lt;static&gt; filesByDate(dir [, opts]) Sorts files by date in folder. Parameters: Name Type Argument Description dir string Path to directory. opts object &lt;optional&gt; Options. Properties Name Type Argument Default Description desc boolean &lt;optional&gt; false Flag to reverse order. Source: index.js, line 96 Returns: Sequence of files sorted by date Type Array.&lt;string&gt; &lt;static&gt; filesByOrder(dir [, opts]) Files sorted by order. Parameters: Name Type Argument Description dir string Path to directory. opts object &lt;optional&gt; Options. Properties Name Type Argument Default Description desc boolean &lt;optional&gt; false Flag to reverse order. Source: index.js, line 126 Returns: Sequence of files sorted by order. Type Array.&lt;string&gt; &lt;static&gt; getReqKey(req) Helper to generate request key for storage. Parameters: Name Type Description req Request Client request. Source: index.js, line 86 Returns: Request key according to its method, host, url. Type string &lt;static&gt; help( [d]) Help Parameters: Name Type Argument Description d function &lt;optional&gt; Function to manage describe message: join, colorize, etc. Source: index.js, line 268 Returns: Preconfigured yargs. Type yargs &lt;static&gt; isInScreen(obj, screen [, opts]) Defines whether object is located on screen or no. Parameters: Name Type Argument Description obj object Object which may be on screen. screen object Screen object. opts object &lt;optional&gt; Options. Properties Name Type Argument Default Description fully boolean &lt;optional&gt; false Flag to check full presence on screen. Source: index.js, line 309 Returns: true if it is on screen, false otherwise. Type boolean &lt;async, static&gt; killProcs(procName) Helper to kill processes by name. Parameters: Name Type Description procName string Process name or chunk of name. Source: index.js, line 239 Returns: Type Promise.&lt;void&gt; &lt;static&gt; makeFixture( [opts]) Glace fixtures factory. Provides easy way to make a fixture with hooks related with shared context. Parameters: Name Type Argument Description opts object &lt;optional&gt; Options. Properties Name Type Argument Description before function &lt;optional&gt; Callback of before hook. after function &lt;optional&gt; Callback of after hook. beforeChunk function &lt;optional&gt; Callback of beforeChunk hook. afterChunk function &lt;optional&gt; Callback of afterChunk hook. Source: index.js, line 630 Returns: Fixture. Type function &lt;static&gt; missedWords(text, words [, firstMissedOnly]) Detects words if they are missed in text (case-sensitive). Parameters: Name Type Argument Default Description text string Text where words are looked for. words Array.&lt;string&gt; Filtered words. firstMissedOnly boolean &lt;optional&gt; false Flag to return first missed word only. It reduces searching time and recommended to use if not need to get all missed words. Source: lib/small.js, line 163 Returns: Array of missed words. Type Array.&lt;string&gt; Example U.missedWords(&quot;hello world&quot;, [&quot;hello&quot;, &quot;man&quot;]); // [&quot;man&quot;] &lt;static&gt; mkpath(paths) Composes file path from segments. If folder of file is absent, it will be created. Parameters: Name Type Argument Description paths string &lt;repeatable&gt; A sequence of paths or path segments. Source: index.js, line 73 Returns: Composed path. Type string &lt;static&gt; objOnScreenPos(obj, screen) Gets object position on screen. Parameters: Name Type Description obj object Object which should be on screen. screen object Screen object. Source: index.js, line 334 Throws: If object isn't located on screen. Type Error Returns: Object position on screen. Type object &lt;static&gt; sleep(timeout [, blocking]) Makes delay (sleep) during code execution. Parameters: Name Type Argument Default Description timeout number Time to sleep, ms. blocking boolean &lt;optional&gt; false Flag whether sleep should be block code execution. Source: index.js, line 52 Returns: If sleep isn't blocking. Type Promise.&lt;void&gt; If sleep is blocking. Type undefined &lt;static&gt; splitBy(s, d) Splits string to array by delimiter. Parameters: Name Type Description s string String to split. d char String delimiter. Source: lib/small.js, line 125 Returns: Type array.&lt;string&gt; Example U.splitBy(&quot;a, b, c&quot;, &quot;,&quot;); // ['a', 'b', 'c'] &lt;static&gt; subFolders(dir [, opts]) Gets subfolders of directory. Parameters: Name Type Argument Description dir string Path to directory. opts object &lt;optional&gt; Options. Properties Name Type Argument Default Description nameOnly boolean &lt;optional&gt; false Gets only folder names. By default, full paths. Source: index.js, line 156 Returns: Sequence of results. Type Array.&lt;string&gt; &lt;static&gt; textContains(string, words) Checks if text contains words or no. Parameters: Name Type Description string string Original text. words string Checking words. Source: lib/small.js, line 139 Returns: true if text contains words, false otherwise. Type boolean Example U.textContains(&quot;hello world&quot;, &quot;hello world&quot;); // true &lt;static&gt; toKebab(str) Transforms string to kebab case. Replace all symbols, except numbers, chars and dots with dashes. Parameters: Name Type Description str string String to transform. Source: index.js, line 366 Returns: Transformed string. Type string &lt;async, static&gt; waitDuring(predicate [, opts]) Waits during a time that predicate returns truly value. Parameters: Name Type Argument Description predicate function Function which should return truly value during timeout. opts object &lt;optional&gt; Options. Properties Name Type Argument Default Description timeout number &lt;optional&gt; 1 Time to wait predicate result, sec. polling number &lt;optional&gt; 0.1 Time to poll predicate result, sec. Source: index.js, line 419 Returns: false if predicate didn't return truly value during expected time. Type Promise.&lt;boolean&gt; Predicate truly value. Type Promise.&lt;object&gt; &lt;async, static&gt; waitFor(predicate [, opts]) Waits for predicate returns truly value. Parameters: Name Type Argument Description predicate function Function which should return truly value during timeout. opts object &lt;optional&gt; Options. Properties Name Type Argument Default Description timeout number &lt;optional&gt; 1 Time to wait for predicate result, sec. polling number &lt;optional&gt; 0.1 Time to poll predicate result, sec. Source: index.js, line 390 Returns: false if predicate didn't return truly value during expected time. Type Promise.&lt;boolean&gt; Predicate truly value. Type Promise.&lt;object&gt; &lt;static&gt; wrap(wrappers, target) Wraps function inside other functions. Parameters: Name Type Description wrappers Array.&lt;function()&gt; List of functions which will wrap target. target function Target function which will be wrapped. Source: index.js, line 225 Returns: Wrapping function. Type function &lt;inner&gt; clearEmptyFolders(folder) Clears empty folders recursive. Parameters: Name Type Description folder string Path to root folder. Source: index.js, line 26 &lt;inner&gt; switchColor( [opts]) Returns function which switches message color. Parameters: Name Type Argument Description opts object &lt;optional&gt; Options. Properties Name Type Argument Default Description c1 string &lt;optional&gt; magenta Color #1. c2 string &lt;optional&gt; cyan Color #2. Source: index.js, line 184 Returns: Function to switch color of passed text in terminal. Type function × Search results Close "},"module-glace-utils.GlaceError.html":{"id":"module-glace-utils.GlaceError.html","title":"Class: GlaceError","body":" GlaceJS Utils Modules glace-utilslib/loggerlib/small Classes LOGglace-utils.GlaceErrorQueue Tutorials Release Notes Global loadJson Class: GlaceError glace-utils. GlaceError A base class for exceptions and errors, which are raised by glacejs framework or its plugins. Any glacejs exception should be inherited from this class for good style. new GlaceError(message) Creates a new instance of glacejs error. Parameters: Name Type Description message string Error message. Source: lib/small.js, line 24 × Search results Close "},"module-lib_logger.html":{"id":"module-lib_logger.html","title":"Module: lib/logger","body":" GlaceJS Utils Modules glace-utilslib/loggerlib/small Classes LOGglace-utils.GlaceErrorQueue Tutorials Release Notes Global loadJson Module: lib/logger GlaceJS logger. Source: lib/logger.js, line 3 Members &lt;inner&gt; logger Properties: Name Type Description logger Logger GlaceJS logger. Source: lib/logger.js, line 26 × Search results Close "},"module-lib_small.html":{"id":"module-lib_small.html","title":"Module: lib/small","body":" GlaceJS Utils Modules glace-utilslib/loggerlib/small Classes LOGglace-utils.GlaceErrorQueue Tutorials Release Notes Global loadJson Module: lib/small Functions &amp; classes, which content is trivial or|and doesn't require complex implementation (&lt;10 SLOC mostly). Source: lib/small.js, line 1 × Search results Close "},"Queue.html":{"id":"Queue.html","title":"Class: Queue","body":" GlaceJS Utils Modules glace-utilslib/loggerlib/small Classes LOGglace-utils.GlaceErrorQueue Tutorials Release Notes Global loadJson Class: Queue Queue new Queue() Tasks queue. Source: lib/pool.js, line 20 Methods add(weight, task) Adds task to queue. Parameters: Name Type Description weight number Task weight. task function Task. Source: lib/pool.js, line 33 × Search results Close "},"tutorial-release-notes.html":{"id":"tutorial-release-notes.html","title":"Tutorial: Release Notes","body":" GlaceJS Utils Modules glace-utilslib/loggerlib/small Classes LOGglace-utils.GlaceErrorQueue Tutorials Release Notes Global loadJson Release Notes v1.3.4 Updated dependencies to fresh versions. v1.3.3 Fixed bug in interactive autocompletion. v1.3.2 Added function to make fixture. v1.3.1 Updated log message format. v1.3.0 Added timestamp to stdout log. Added alias coalesce for defVal. Fixed bug that --help didn't show help menu. v1.2.9 Fixed bug that autocompletion in debug mode didn't work for objects started with $. Provided help message customization in debug mode. v1.2.8 Added function splitBy. v1.2.7 Added function each2each to create combinations. v1.2.6 Destroy file stream on network error. v1.2.5 Destroy file stream on download error. v1.2.4 Mentioned log levels in help. v1.2.3 Added download timeout option. v1.2.2 Fixed bug in download function in order to download only 200-response files. v1.2.1 Added function to download files. v1.2.0 Provided logger options in config. v1.1.9 Expanded logs of processes killing. v1.1.8 Don't kill parent process. v1.1.7 Added helper textContains. Added infrastructure scripts. v1.1.6 Added support for docstring style in js functions. Added helper waitDuring. v1.1.5 Expanded list of autocomplete variants. v1.1.4 Fixed bug that autocomplete didn't show full list of object properties. v1.1.3 Added GlaceError class. v1.1.2 Fixed bug that killProcs killed current process. v1.1.1 Fixed bug that code completion showed variants which are started with numbers or contain non-alphanumeric symbols. v1.1.0 Fixed bugs, that it wasn't possible to assign variables and not all object properties and methods were shown. v1.0.8 Added interactive debugger. v1.0.7 Added function waitFor. v1.0.6 Added function objOnScreenPos. v1.0.5 Added functions isInScene and toKebab. v1.0.4 Supports recursive json load if key __parent with path to parent json is specified in json file. Arguments config file supports __parent key too. v1.0.3 Fixed bug, that internal module variable logger was defined only if global variable __glaceLogger wasn't defined before. × Search results Close "}}
    </script>

    <script type="text/javascript">
        $(document).ready(function() {
            Searcher.init();
        });

        $(window).on("message", function(msg) {
            var msgData = msg.originalEvent.data;

            if (msgData.msgid != "docstrap.quicksearch.start") {
                return;
            }

            var results = Searcher.search(msgData.searchTerms);

            window.parent.postMessage({"results": results, "msgid": "docstrap.quicksearch.done"}, "*");
        });
    </script>
</body>
</html>
