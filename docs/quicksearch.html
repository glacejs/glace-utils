<html>
<head>
</head>
<body style="background: transparent;">
    <script src="scripts/docstrap.lib.js"></script>
    <script src="scripts/lunr.min.js"></script>
    <script src="scripts/fulltext-search.js"></script>

    <script type="text/x-docstrap-searchdb">
    {"index.js.html":{"id":"index.js.html","title":"Source: index.js","body":" GlaseJS Utils Modules index Classes index~GlaceError Tutorials Release Notes Source: index.js /** * `GlaceJS` utils. * * @module */ var fs = require(&quot;fs&quot;); var os = require(&quot;os&quot;); var path = require(&quot;path&quot;); var readline = require(&quot;readline&quot;); var util = require(&quot;util&quot;); var BaseError = require(&quot;es6-error&quot;); var colors = require(&quot;colors&quot;); var espree = require(&quot;espree&quot;); var highlight = require(&quot;cli-highlight&quot;).highlight; var _ = require(&quot;lodash&quot;); var yargs = require(&quot;yargs&quot;); module.exports.__findProcess = require(&quot;find-process&quot;); var fse = require(&quot;fs-extra&quot;); var json = require(&quot;comment-json&quot;); var winston = require(&quot;winston&quot;); var argv = yargs.argv; /** * Creates new instance of `Glace` error. * * @class * @arg {string} message - Error message. */ var GlaceError = module.exports.GlaceError = function (message) { BaseError.call(this, message); }; util.inherits(GlaceError, BaseError); /** * @property {string} hostname - Machine host name. */ module.exports.hostname = os.hostname().toLowerCase(); /** * Gets default value for variable among passed listed values. * * @function * @arg {...*} values - Sequence of variable values. * @return {*} Last specified value or null if last is undefined. */ var defVal = module.exports.defVal = function () { for (var arg of arguments) if (typeof arg !== &quot;undefined&quot;) return arg; return null; }; /** * Capitalizes first letter of string. Doesn&quot;t influence to case * of other letters. * * @function * @arg {string} string - String to capitalize. * @return {string} Capitalized string. */ module.exports.capitalize = string =&gt; { return string.charAt(0).toUpperCase() + string.slice(1); }; /** * Clears empty folders recursive. * * @function * @arg {string} folder - Path to root folder. */ var clearEmptyFolders = module.exports.clearEmptyFolders = folder =&gt; { var files = fs.readdirSync(folder); for (var fileName of files) { var filePath = path.join(folder, fileName); if (fs.statSync(filePath).isDirectory()) { clearEmptyFolders(filePath); }; }; if (!_.isEmpty(files)) { files = fs.readdirSync(folder); }; if (_.isEmpty(files)) { fs.rmdirSync(folder); }; }; /** * Makes delay (sleep) during code execution. * * @function * @arg {number} timeout - Time to sleep, ms. * @arg {boolean} [blocking=false] - Flag whether sleep should be * block code execution. * @return {Promise&lt;void&gt;} If sleep isn't blocking. * @return {undefined} If sleep is blocking. */ module.exports.sleep = (timeout, blocking) =&gt; { blocking = !!blocking; if (blocking) { (ms =&gt; { ms += new Date().getTime(); while (new Date() &lt; ms) {}; })(timeout); } else { return new Promise(resolve =&gt; { setTimeout(resolve, timeout); }); }; }; /** * Composes file path from segments. If folder of file is absent, it will * be created. * * @function * @arg {...string} paths - A sequence of paths or path segments. * @return {string} Composed path. */ module.exports.mkpath = function () { var result = path.resolve.apply(path, arguments); var dirname = path.dirname(result); fse.mkdirsSync(dirname); return result; }; /** * Helper to generate request key for storage. * * @function * @arg {Request} req - Client request. * @return {string} Request key according to its method, host, url. */ module.exports.getReqKey = req =&gt; req.method + &quot;_&quot; + req.headers.host + req.url; /** * Sorts files by date in folder. * * @function * @arg {string} dir - Path to directory. * @arg {object} [opts] - Options. * @arg {boolean} [opts.desc=false] - Flag to reverse order. * @return {string[]} Sequence of files sorted by date */ module.exports.filesByDate = (dir, opts) =&gt; { opts = opts || {}; opts.desc = opts.desc || false; var filesList = fs .readdirSync(dir) .filter(filename =&gt; { var filePath = path.resolve(dir, filename); return !fs.statSync(filePath).isDirectory(); }) .map(filename =&gt; { var filePath = path.resolve(dir, filename); return { path: filePath, time: fs.statSync(filePath).mtime.getTime() }; }) .sort((a, b) =&gt; a.time - b.time) .map(el =&gt; el.path); if (opts.desc) filesList.reverse(); return filesList; }; /** * Files sorted by order. * * @function * @arg {string} dir - Path to directory. * @arg {object} [opts] - Options. * @arg {boolean} [opts.desc=false] - Flag to reverse order. * @return {string[]} Sequence of files sorted by order. */ module.exports.filesByOrder = (dir, opts) =&gt; { opts = opts || {}; opts.desc = opts.desc || false; var filesList = fs .readdirSync(dir) .filter(filename =&gt; { var filePath = path.resolve(dir, filename); return !fs.statSync(filePath).isDirectory(); }) .map(filename =&gt; { return { path: path.resolve(dir, filename), number: parseInt(_.split(filename, '-', 1)[0]) || 0 }; }) .sort((a, b) =&gt; a.number - b.number) .map(el =&gt; el.path); if (opts.desc) filesList.reverse(); return filesList; }; /** * Gets subfolders of directory. * * @function * @arg {string} dir - Path to directory. * @arg {object} [opts] - Options. * @arg {boolean} [opts.nameOnly=false] - Gets only folder names. By default, * full paths. * @return {string[]} Sequence of results. */ module.exports.subFolders = (dir, opts) =&gt; { opts = opts || {}; opts.nameOnly = opts.nameOnly || false; if (!fs.existsSync(dir)) return []; var dirsList = fs .readdirSync(dir) .filter(filename =&gt; { var filePath = path.resolve(dir, filename); return fs.statSync(filePath).isDirectory(); }); if (!opts.nameOnly) { dirsList = dirsList.map(name =&gt; path.resolve(dir, name)); }; return dirsList; } /** * Returns function which switches message color. * * @function * @arg {object} [opts] - Options. * @arg {string} [opts.c1=magenta] - Color #1. * @arg {string} [opts.c2=cyan] - Color #2. * @return {function} Function to switch color of passed text in terminal. */ module.exports.switchColor = opts =&gt; { opts = opts || {}; var c1 = opts.c1 || &quot;magenta&quot;; var c2 = opts.c2 || &quot;cyan&quot;; var trigger = true; return function () { var msg = Array.from(arguments).join(&quot; &quot;); msg = msg[trigger ? c1 : c2].bold; trigger = !trigger; return msg; }; }; /** * Exits process with error printing. * * @function * @arg {string} source - Source of fatal error. * @return {function} Function with takes error to print and exits process. */ module.exports.exit = source =&gt; err =&gt; { console.log(source + &quot;:&quot;, err); process.exit(1); }; /** * @prop {string} cwd - Current work directory. */ var cwd = module.exports.cwd = process.cwd(); /** * Loads json file which may have comments. * * If json file has key `__parent` with path to parent json * it will be loaded and merged recursively. * * @function * @arg {string} name - Name of JSON file. * @return {object} - Object. * @throws {Error} If JSON file isn't parsable. * @throws {Error} If there is circular parent reference. */ var loadJson = module.exports.loadJson = name =&gt; { var alreadyLoaded = []; var load = name =&gt; { if (!name.endsWith(&quot;.json&quot;)) name += &quot;.json&quot;; var jsonPath = path.resolve(cwd, name); if (alreadyLoaded.includes(jsonPath)) { throw new Error( `Circular reference detected, '${jsonPath}' is loaded already`); }; alreadyLoaded.push(jsonPath); try { var result = json.parse( fs.readFileSync(jsonPath).toString(), null, true); } catch (e) { throw new Error(`Can't parse ${jsonPath}. ${e}`); }; if (result.__parent) { var parent = load(result.__parent); result = _.merge(parent, result); }; delete result.__parent; return result; }; return load(name); }; /* Logger */ if (global.__glaceLogger) { var logger = module.exports.logger = global.__glaceLogger; } else { /** * @prop {Logger} logger - `GlaceJS` logger. */ var logger = module.exports.logger = global.__glaceLogger = new winston.Logger(); logger.level = argv.logLevel || &quot;debug&quot;; logger.add(winston.transports.File, { filename: path.resolve(cwd, argv.log || &quot;glace.log&quot;), json: false }); if (argv.stdoutLog) { logger.add(winston.transports.Console); }; /** * Sets log file to logger. * * @function * @arg {string} logFile - Name or path of log file. */ logger.setFile = logFile =&gt; { var logPath = path.resolve(cwd, logFile); if (!logPath.endsWith(&quot;.log&quot;)) logPath += &quot;.log&quot;; fse.mkdirsSync(path.dirname(logPath)); if (logger.transports.file) logger.remove(winston.transports.File); logger.add(winston.transports.File, { filename: logPath, json: false }); }; /** * Gets log file. * * @function * @return {?string} Path to log file or `null`. */ logger.getFile = () =&gt; { if (!logger.transports.file) return null; return path.resolve(cwd, logger.transports.file.filename); }; /** * Resets log file. * * @function */ logger.resetFile = () =&gt; { var logPath = logger.getFile(); if (!logPath) return; fs.unlinkSync(logPath); logger.setFile(logPath); }; }; /* Config */ if (global.__glaceConfig) { module.exports.config = global.__glaceConfig; } else { /** * @prop {object} config - `GlaceJS` config. */ var config = module.exports.config = global.__glaceConfig = {}; var argsConfig = {}; var argsConfigPath = path.resolve(cwd, (argv.c || argv.config || &quot;config.json&quot;)); if (fs.existsSync(argsConfigPath)) { argsConfig = loadJson(argsConfigPath); for (var key in argsConfig) { var val = argsConfig[key]; argsConfig[_.camelCase(key)] = val; }; }; _.mergeWith(argsConfig, argv, (objVal, srcVal) =&gt; srcVal ? srcVal : objVal); config.args = argsConfig; }; /** * Wraps function inside other functions. * * @function * @arg {function[]} wrappers - List of functions which will wrap target. * @arg {function} target - Target function which will be wrapped. * @return {function} Wrapping function. */ module.exports.wrap = (wrappers, target) =&gt; { _.clone(wrappers).reverse().forEach(wrapper =&gt; { target = (target =&gt; () =&gt; wrapper(target))(target); }); return target; }; /** * Helper to kill processes by name. * * @async * @function * @arg {string} procName - Process name or chunk of name. * @return {Promise&lt;void&gt;} */ module.exports.killProcs = procName =&gt; { return self.__findProcess(&quot;name&quot;, procName).then(procList =&gt; { return procList.forEach(proc =&gt; { if (process.pid === +proc.pid) return; try { process.kill(proc.pid, &quot;SIGTERM&quot;); logger.debug(`Kill ${procName} with PID ${proc.pid}`); } catch (e) { if (e.message !== &quot;kill ESRCH&quot;) throw e; logger.error(`Can't kill ${procName} with PID ${proc.pid}`, `because it doesn't exist`); }; }); }); }; /** * Help * * @function * @arg {function} d - Function to manage describe message: join, colorize, etc. * @return {yargs} Preconfigured yargs. */ module.exports.help = d =&gt; { return yargs .options({ &quot;config [path]&quot;: { alias: &quot;c&quot;, describe: d(&quot;Path to JSON file with CLI arguments.&quot;, &quot;Default is 'cwd/config.json' (if it exists).&quot;), type: &quot;string&quot;, group: &quot;Arguments:&quot;, }, &quot;stdout-log&quot;: { describe: d(&quot;Print log messages to stdout.&quot;), type: &quot;boolean&quot;, group: &quot;Log:&quot;, }, &quot;log [path]&quot;: { describe: d(&quot;Path to log file. Default is 'cwd/glace.log'.&quot;), type: &quot;string&quot;, group: &quot;Log:&quot;, }, &quot;log-level [level]&quot;: { describe: d(&quot;Log level. Default is 'debug'.&quot;), type: &quot;string&quot;, group: &quot;Log:&quot;, }, }) .help(&quot;h&quot;) .alias(&quot;h&quot;, &quot;help&quot;); }; /** * Defines whether object is located on screen or no. * * @function * @arg {object} obj - Object which may be on screen. * @arg {object} screen - Screen object. * @arg {object} [opts] - Options. * @arg {boolean} [opts.fully=false] - Flag to check full presence on screen. * @return {boolean} `true` if it is on screen, `false` otherwise. */ module.exports.isInScreen = (obj, screen, opts) =&gt; { opts = defVal(opts, {}); var fully = defVal(opts.fully, false); if (fully) { return ((obj.x &gt;= screen.x) &amp;&amp; (obj.y &gt;= screen.y) &amp;&amp; (obj.x + obj.width &lt;= screen.x + screen.width) &amp;&amp; (obj.y + obj.height &lt;= screen.y + screen.height)); } else { return !((obj.x &gt;= screen.x + screen.width) || (obj.y &gt;= screen.y + screen.height) || (obj.x + obj.width &lt;= screen.x) || (obj.y + obj.height &lt;= screen.y)); }; }; /** * Gets object position on screen. * * @function * @arg {object} obj - Object which should be on screen. * @arg {object} screen - Screen object. * @return {object} Object position on screen. * @throws {Error} If object isn't located on screen. */ module.exports.objOnScreenPos = (obj, screen) =&gt; { if (!self.isInScreen(obj, screen)) { throw new Error( `Object { x: ${obj.x}, y: ${obj.y}, width: ${obj.width}, ` + `height: ${obj.height} } isn't on screen { x: ${screen.x}, ` + `y: ${screen.y}, width: ${screen.width}, height: ${screen.height} }`); }; var res = _.clone(obj); if (res.x &lt; screen.x) res.x = screen.x; if (res.y &lt; screen.y) res.y = screen.y; if (res.x + res.width &gt; screen.x + screen.width) { res.width = screen.x + screen.width - res.x; }; if (res.y + res.height &gt; screen.y + screen.height) { res.height = screen.y + screen.height - res.y; }; return res; }; /** * Transforms string to kebab case. Replace all symbols, except numbers, * chars and dots with dashes. * * @function * @arg {string} str - String to transform. * @return {string} Transformed string. */ module.exports.toKebab = str =&gt; { return str .trim() .toLowerCase() .replace(/[^A-Za-z0-9_\\.]+/g, &quot;-&quot;) .replace(/\\-\\./g, &quot;.&quot;) .replace(/\\-\\_/g, &quot;_&quot;) .replace(/\\-$/g, &quot;&quot;) .replace(/^\\-/g, &quot;&quot;); }; /** * Waits for predicate returns truly value. * * @async * @function * @arg {function} predicate - Function which should return truly value during * timeout. * @arg {object} [opts] - Options. * @arg {number} [opts.timeout=1] - Time to wait for predicate result, sec. * @arg {number} [opts.polling=0.1] - Time to poll predicate result, sec. * @return {Promise&lt;boolean&gt;} `false` if predicate didn't return truly value * during expected time. * @return {Promise&lt;object&gt;} Predicate truly value. */ module.exports.waitFor = async (predicate, opts) =&gt; { opts = self.defVal(opts, {}); var timeout = self.defVal(opts.timeout, 1) * 1000; var polling = self.defVal(opts.polling, 0.1) * 1000; var limit = new Date().getTime() + timeout; while(limit &gt; new Date().getTime()) { var result = await predicate(); if (result) return result; await self.sleep(polling); }; return false; }; var complete = line =&gt; { line = colors.strip(line); var tokens = line.split(/ /).filter(i =&gt; i); if (!tokens.length) return [[], line]; var targetToken = tokens[tokens.length - 1]; var namespace = global; var filterPrefix = targetToken; var targetObject; if (targetToken.includes(&quot;.&quot;)) { targetObject = targetToken.split('.'); filterPrefix = targetObject.pop(); targetObject = targetObject.join(&quot;.&quot;); if (!targetObject) return [[], line]; try { namespace = eval(targetObject); } catch (e) { return [[], line]; }; }; try { var completions = _.union( Object.getOwnPropertyNames(namespace), Object.getOwnPropertyNames(Object.getPrototypeOf(namespace)) ).sort() .filter(i =&gt; i.startsWith(filterPrefix)) .filter(i =&gt; /^\\w+$/.test(i)) .filter(i =&gt; /^\\D/.test(i)); } catch (e) { return [[], line]; }; if (targetObject) { completions = completions.map(i =&gt; targetObject + &quot;.&quot; + i); }; return [completions, line]; }; /** * Interactive debugger. * * @async * @function * @return {Promise} */ module.exports.debug = async function () { console.log(&quot;interactive mode&quot;.yellow); var rl = readline.createInterface({ input: process.stdin, output: process.stdout, completer: complete, }); var ttyWrite = rl._ttyWrite; rl._ttyWrite = function (s, key) { if (this.cursor &lt;= this.line.length) { this.line = colors.strip(this.line); if (this.cursor &gt; this.line.length) { this._moveCursor(+Infinity); }; }; ttyWrite.call(this, s, key); if (this.cursor &lt; this.line.length) { this.line = colors.strip(this.line); if (this.cursor &gt; this.line.length) { this._moveCursor(+Infinity); }; } else { this.line = highlight(colors.strip(this.line), { language: &quot;js&quot; }); this._moveCursor(+Infinity); }; if (key.name !== &quot;return&quot;) { this._refreshLine(); }; }; var origGlobals = {}; var isFinished = false; while (!isFinished) { isFinished = await new Promise((resolve, reject) =&gt; { rl.question(&quot;&gt; &quot;.red, answer =&gt; { answer = colors.strip(answer); if (answer === &quot;exit&quot;) { console.log(&quot;emergency exit&quot;.red) process.exit(1); }; if (answer === &quot;go&quot;) { console.log(&quot;continue execution&quot;.green); resolve(true); return; }; if ([&quot;help&quot;, &quot;h&quot;].includes(answer)) { console.log((&quot;In interactive mode you may execute any nodejs code.\\n&quot; + &quot;Also next commands are available:\\n&quot; + &quot;- h, help - show interactive mode help;\\n&quot; + &quot;- go - continue code execution;\\n&quot; + &quot;- exit - finish current nodejs process;&quot;).white); resolve(false); return; }; var ast, varName; try { ast = espree.parse(answer, { ecmaVersion: 9 }); varName = ast.body[0].expression.left.name; } catch (e) { try { varName = ast.body[0].declarations[0].id.name; } catch (e) {}; }; Promise .resolve() .then(() =&gt; { var result = eval(answer); if (varName) { if (!origGlobals.hasOwnProperty(varName)) { origGlobals[varName] = global[varName]; }; global[varName] = eval(varName); }; return result; }) .then(result =&gt; console.log(util.format(result).yellow)) .catch(e =&gt; console.log(util.format(e).red)) .then(() =&gt; resolve(false)); }); }); }; for (var [k, v] of Object.entries(origGlobals)) { global[k] = v; }; }; var self = module.exports; × Search results Close "},"modules.list.html":{"id":"modules.list.html","title":"Modules","body":" GlaseJS Utils Modules index Classes index~GlaceError Tutorials Release Notes Modules Classes GlaceError × Search results Close "},"classes.list.html":{"id":"classes.list.html","title":"Classes","body":" GlaseJS Utils Modules index Classes index~GlaceError Tutorials Release Notes Classes Classes GlaceError × Search results Close "},"tutorials.list.html":{"id":"tutorials.list.html","title":"Tutorials","body":" GlaseJS Utils Modules index Classes index~GlaceError Tutorials Release Notes Tutorials Classes GlaceError × Search results Close "},"index.html":{"id":"index.html","title":"Index","body":" GlaseJS Utils Modules index Classes index~GlaceError Tutorials Release Notes | Source Code | Release Notes GlaceJS framework utilities × Search results Close "},"module-index.html":{"id":"module-index.html","title":"Module: index","body":" GlaseJS Utils Modules index Classes index~GlaceError Tutorials Release Notes Module: index GlaceJS utils. Source: index.js, line 1 Classes GlaceError Members &lt;static&gt; hostname Properties: Name Type Description hostname string Machine host name. Source: index.js, line 40 &lt;inner&gt; config Properties: Name Type Description config object GlaceJS config. Source: index.js, line 359 &lt;inner&gt; cwd Properties: Name Type Description cwd string Current work directory. Source: index.js, line 256 &lt;inner&gt; logger Properties: Name Type Description logger Logger GlaceJS logger. Source: index.js, line 307 Methods &lt;static&gt; capitalize(string) Capitalizes first letter of string. Doesn&quot;t influence to case of other letters. Parameters: Name Type Description string string String to capitalize. Source: index.js, line 62 Returns: Capitalized string. Type string &lt;async, static&gt; debug() Interactive debugger. Source: index.js, line 609 Returns: Type Promise &lt;static&gt; exit(source) Exits process with error printing. Parameters: Name Type Description source string Source of fatal error. Source: index.js, line 249 Returns: Function with takes error to print and exits process. Type function &lt;static&gt; filesByDate(dir [, opts]) Sorts files by date in folder. Parameters: Name Type Argument Description dir string Path to directory. opts object &lt;optional&gt; Options. Properties Name Type Argument Default Description desc boolean &lt;optional&gt; false Flag to reverse order. Source: index.js, line 141 Returns: Sequence of files sorted by date Type Array.&lt;string&gt; &lt;static&gt; filesByOrder(dir [, opts]) Files sorted by order. Parameters: Name Type Argument Description dir string Path to directory. opts object &lt;optional&gt; Options. Properties Name Type Argument Default Description desc boolean &lt;optional&gt; false Flag to reverse order. Source: index.js, line 171 Returns: Sequence of files sorted by order. Type Array.&lt;string&gt; &lt;static&gt; getReqKey(req) Helper to generate request key for storage. Parameters: Name Type Description req Request Client request. Source: index.js, line 131 Returns: Request key according to its method, host, url. Type string &lt;static&gt; help(d) Help Parameters: Name Type Description d function Function to manage describe message: join, colorize, etc. Source: index.js, line 423 Returns: Preconfigured yargs. Type yargs &lt;static&gt; isInScreen(obj, screen [, opts]) Defines whether object is located on screen or no. Parameters: Name Type Argument Description obj object Object which may be on screen. screen object Screen object. opts object &lt;optional&gt; Options. Properties Name Type Argument Default Description fully boolean &lt;optional&gt; false Flag to check full presence on screen. Source: index.js, line 462 Returns: true if it is on screen, false otherwise. Type boolean &lt;async, static&gt; killProcs(procName) Helper to kill processes by name. Parameters: Name Type Description procName string Process name or chunk of name. Source: index.js, line 397 Returns: Type Promise.&lt;void&gt; &lt;static&gt; mkpath(paths) Composes file path from segments. If folder of file is absent, it will be created. Parameters: Name Type Argument Description paths string &lt;repeatable&gt; A sequence of paths or path segments. Source: index.js, line 118 Returns: Composed path. Type string &lt;static&gt; objOnScreenPos(obj, screen) Gets object position on screen. Parameters: Name Type Description obj object Object which should be on screen. screen object Screen object. Source: index.js, line 487 Throws: If object isn't located on screen. Type Error Returns: Object position on screen. Type object &lt;static&gt; sleep(timeout [, blocking]) Makes delay (sleep) during code execution. Parameters: Name Type Argument Default Description timeout number Time to sleep, ms. blocking boolean &lt;optional&gt; false Flag whether sleep should be block code execution. Source: index.js, line 97 Returns: If sleep isn't blocking. Type Promise.&lt;void&gt; If sleep is blocking. Type undefined &lt;static&gt; subFolders(dir [, opts]) Gets subfolders of directory. Parameters: Name Type Argument Description dir string Path to directory. opts object &lt;optional&gt; Options. Properties Name Type Argument Default Description nameOnly boolean &lt;optional&gt; false Gets only folder names. By default, full paths. Source: index.js, line 201 Returns: Sequence of results. Type Array.&lt;string&gt; &lt;static&gt; switchColor( [opts]) Returns function which switches message color. Parameters: Name Type Argument Description opts object &lt;optional&gt; Options. Properties Name Type Argument Default Description c1 string &lt;optional&gt; magenta Color #1. c2 string &lt;optional&gt; cyan Color #2. Source: index.js, line 229 Returns: Function to switch color of passed text in terminal. Type function &lt;static&gt; toKebab(str) Transforms string to kebab case. Replace all symbols, except numbers, chars and dots with dashes. Parameters: Name Type Description str string String to transform. Source: index.js, line 519 Returns: Transformed string. Type string &lt;async, static&gt; waitFor(predicate [, opts]) Waits for predicate returns truly value. Parameters: Name Type Argument Description predicate function Function which should return truly value during timeout. opts object &lt;optional&gt; Options. Properties Name Type Argument Default Description timeout number &lt;optional&gt; 1 Time to wait for predicate result, sec. polling number &lt;optional&gt; 0.1 Time to poll predicate result, sec. Source: index.js, line 543 Returns: false if predicate didn't return truly value during expected time. Type Promise.&lt;boolean&gt; Predicate truly value. Type Promise.&lt;object&gt; &lt;static&gt; wrap(wrappers, target) Wraps function inside other functions. Parameters: Name Type Description wrappers Array.&lt;function()&gt; List of functions which will wrap target. target function Target function which will be wrapped. Source: index.js, line 383 Returns: Wrapping function. Type function &lt;inner&gt; clearEmptyFolders(folder) Clears empty folders recursive. Parameters: Name Type Description folder string Path to root folder. Source: index.js, line 71 &lt;inner&gt; defVal(values) Gets default value for variable among passed listed values. Parameters: Name Type Argument Description values * &lt;repeatable&gt; Sequence of variable values. Source: index.js, line 48 Returns: Last specified value or null if last is undefined. Type * &lt;inner&gt; loadJson(name) Loads json file which may have comments. If json file has key __parent with path to parent json it will be loaded and merged recursively. Parameters: Name Type Description name string Name of JSON file. Source: index.js, line 269 Throws: If JSON file isn't parsable. Type Error If there is circular parent reference. Type Error Returns: Object. Type object × Search results Close "},"module-index-GlaceError.html":{"id":"module-index-GlaceError.html","title":"Class: GlaceError","body":" GlaseJS Utils Modules index Classes index~GlaceError Tutorials Release Notes Class: GlaceError index~ GlaceError new GlaceError(message) Creates new instance of Glace error. Parameters: Name Type Description message string Error message. Source: index.js, line 32 × Search results Close "},"tutorial-release-notes.html":{"id":"tutorial-release-notes.html","title":"Tutorial: Release Notes","body":" GlaseJS Utils Modules index Classes index~GlaceError Tutorials Release Notes Release Notes v1.1.3 Added GlaceError class. v1.1.2 Fixed bug that killProcs killed current process. v1.1.1 Fixed bug that code completion showed variants which are started with numbers or contain non-alphanumeric symbols. v1.1.0 Fixed bugs, that it wasn't possible to assign variables and not all object properties and methods were shown. v1.0.8 Added interactive debugger. v1.0.7 Added function waitFor. v1.0.6 Added function objOnScreenPos. v1.0.5 Added functions isInScene and toKebab. v1.0.4 Supports recursive json load if key __parent with path to parent json is specified in json file. Arguments config file supports __parent key too. v1.0.3 Fixed bug, that internal module variable logger was defined only if global variable __glaceLogger wasn't defined before. × Search results Close "}}
    </script>

    <script type="text/javascript">
        $(document).ready(function() {
            Searcher.init();
        });

        $(window).on("message", function(msg) {
            var msgData = msg.originalEvent.data;

            if (msgData.msgid != "docstrap.quicksearch.start") {
                return;
            }

            var results = Searcher.search(msgData.searchTerms);

            window.parent.postMessage({"results": results, "msgid": "docstrap.quicksearch.done"}, "*");
        });
    </script>
</body>
</html>
