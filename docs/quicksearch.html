<html>
<head>
</head>
<body style="background: transparent;">
    <script src="scripts/docstrap.lib.js"></script>
    <script src="scripts/lunr.min.js"></script>
    <script src="scripts/fulltext-search.js"></script>

    <script type="text/x-docstrap-searchdb">
    {"index.js.html":{"id":"index.js.html","title":"Source: index.js","body":" GlaseJS Utils Modules index Source: index.js &quot;use strict&quot;; /** * `GlaceJS` utils. * * @module */ var fs = require(&quot;fs&quot;); var os = require(&quot;os&quot;); var path = require(&quot;path&quot;); require(&quot;colors&quot;); var _ = require(&quot;lodash&quot;); var argv = require(&quot;yargs&quot;).argv; var findProcess = require(&quot;find-process&quot;); var fse = require(&quot;fs-extra&quot;); var json = require(&quot;comment-json&quot;); var winston = require(&quot;winston&quot;); /** * @property {string} hostname - Machine host name. */ module.exports.hostname = os.hostname().toLowerCase(); /** * Gets default value for variable among passed listed values. * * @function * @arg {...*} values - variable values * @return {*} - last specified value or null if last is undefined. */ module.exports.defVal = function () { for (var arg of arguments) if (typeof arg !== &quot;undefined&quot;) return arg; return null; }; /** * Capitalizes first letter of string. Doesn&quot;t influence to case * of other letters. * * @function * @arg {string} string - string to capitalize * @return {string} - capitalized string */ module.exports.capitalize = string =&gt; { return string.charAt(0).toUpperCase() + string.slice(1); }; /** * Clears empty folders recursive. * * @function * @arg {string} folder - path to root folder */ var clearEmptyFolders = module.exports.clearEmptyFolders = folder =&gt; { var files = fs.readdirSync(folder); for (var fileName of files) { var filePath = path.join(folder, fileName); if (fs.statSync(filePath).isDirectory()) { clearEmptyFolders(filePath); }; }; if (!_.isEmpty(files)) { files = fs.readdirSync(folder); }; if (_.isEmpty(files)) { fs.rmdirSync(folder); }; }; /** * Makes delay (sleep) during code execution. * * @function * @arg {number} timeout - Time to sleep, ms. * @arg {boolean} [blocking=false] - Flag whether sleep should be * block code execution. * @return {Promise} - If sleep isn't blocking. * @return {undefined} - If sleep is blocking. */ module.exports.sleep = (timeout, blocking) =&gt; { blocking = !!blocking; if (blocking) { (ms =&gt; { ms += new Date().getTime(); while (new Date() &lt; ms) {}; })(timeout); } else { return new Promise(resolve =&gt; { setTimeout(resolve, timeout); }); }; }; /** * Composes file path from segments. If folder of file is absent, it will * be created. * * @function * @arg {...string} paths - A sequence of paths or path segments. * @return {string} - Composed path. */ module.exports.mkpath = function () { var result = path.resolve.apply(path, arguments); var dirname = path.dirname(result); fse.mkdirsSync(dirname); return result; }; /** * Helper to generate request key for storage. * * @function * @arg {Request} req - Client request. * @return {string} - Request key according to its method, host, url. */ module.exports.getReqKey = req =&gt; req.method + &quot;_&quot; + req.headers.host + req.url; /** * Sorts files by date in folder. * * @function * @arg {string} dir - Path to directory. * @arg {object} [opts] - Options. * @arg {boolean} [opts.desc=false] - Flag to reverse order. * @return {string[]} - Sequence of files sorted by date */ module.exports.filesByDate = (dir, opts) =&gt; { opts = opts || {}; opts.desc = opts.desc || false; var filesList = fs .readdirSync(dir) .filter(filename =&gt; { var filePath = path.resolve(dir, filename); return !fs.statSync(filePath).isDirectory(); }) .map(filename =&gt; { var filePath = path.resolve(dir, filename); return { path: filePath, time: fs.statSync(filePath).mtime.getTime() }; }) .sort((a, b) =&gt; a.time - b.time) .map(el =&gt; el.path); if (opts.desc) filesList.reverse(); return filesList; }; /** * Files sorted by order. * * @function * @arg {string} dir - Path to directory. * @arg {object} [opts] - Options. * @arg {boolean} [opts.desc=false] - Flag to reverse order. * @return {string[]} - Sequence of files sorted by order. */ module.exports.filesByOrder = (dir, opts) =&gt; { opts = opts || {}; opts.desc = opts.desc || false; var filesList = fs .readdirSync(dir) .filter(filename =&gt; { var filePath = path.resolve(dir, filename); return !fs.statSync(filePath).isDirectory(); }) .map(filename =&gt; { return { path: path.resolve(dir, filename), number: parseInt(_.split(filename, '-', 1)[0]) || 0 }; }) .sort((a, b) =&gt; a.number - b.number) .map(el =&gt; el.path); if (opts.desc) filesList.reverse(); return filesList; }; /** * Gets subfolders of directory. * * @function * @arg {string} dir - Path to directory. * @arg {object} [opts] - Options. * @arg {boolean} [opts.nameOnly=false] - Gets only folder names. By default, * full paths. * @return {string[]} - Sequence of results. */ module.exports.subFolders = (dir, opts) =&gt; { opts = opts || {}; opts.nameOnly = opts.nameOnly || false; if (!fs.existsSync(dir)) return []; var dirsList = fs .readdirSync(dir) .filter(filename =&gt; { var filePath = path.resolve(dir, filename); return fs.statSync(filePath).isDirectory(); }); if (!opts.nameOnly) { dirsList = dirsList.map(name =&gt; path.resolve(dir, name)); }; return dirsList; } /** * Returns function which switches message color. * * @function * @arg {object} [opts] - Options. * @arg {string} [opts.c1=magenta] - Color #1. * @arg {string} [opts.c2=cyan] - Color #2. * @return {function} - Function to switch color of passed text in terminal. */ module.exports.switchColor = opts =&gt; { opts = opts || {}; var c1 = opts.c1 || &quot;magenta&quot;; var c2 = opts.c2 || &quot;cyan&quot;; var trigger = true; return function () { var msg = Array.from(arguments).join(&quot; &quot;); msg = msg[trigger ? c1 : c2].bold; trigger = !trigger; return msg; }; }; /** * Exits process with error printing. * * @function * @arg {string} source - Source of fatal error. * @return {function} - Function with takes error to print and exits process. */ module.exports.exit = source =&gt; err =&gt; { console.log(source + &quot;:&quot;, err); process.exit(1); }; /** * @prop {string} cwd - Current work directory. */ var cwd = module.exports.cwd = process.cwd(); /** * Loads json file which may have comments. * * @function * @param {string} name - Name of JSON file. * @return {object} - Object. * @throws {Error} - If JSON file isn't parsable. */ var loadJson = module.exports.loadJson = name =&gt; { if (!name.endsWith(&quot;.json&quot;)) name += &quot;.json&quot;; var jsonPath = path.resolve(cwd, name); try { return json.parse(fs.readFileSync(jsonPath).toString(), null, true); } catch (e) { throw new Error(`Can't parse ${jsonPath}. ${e}`); }; }; /* Logger */ if (global.__glaceLogger) { module.exports.logger = global.__glaceLogger; } else { /** * @prop {Logger} logger - `GlaceJS` logger. */ var logger = module.exports.logger = global.__glaceLogger = new winston.Logger(); logger.level = argv.logLevel || &quot;debug&quot;; logger.add(winston.transports.File, { filename: path.resolve(cwd, argv.log || &quot;glace.log&quot;), json: false }); if (argv.stdoutLog) { logger.add(winston.transports.Console); }; /** * Sets log file to logger. * * @function * @param {string} logFile - Name or path of log file. */ logger.setFile = logFile =&gt; { var logPath = path.resolve(cwd, logFile); if (!logPath.endsWith(&quot;.log&quot;)) logPath += &quot;.log&quot;; fse.mkdirsSync(path.dirname(logPath)); if (logger.transports.file) logger.remove(winston.transports.File); logger.add(winston.transports.File, { filename: logPath, json: false }); }; /** * Gets log file. * * @function * @return {?string} - Path to log file or `null`. */ logger.getFile = () =&gt; { if (!logger.transports.file) return null; return path.resolve(cwd, logger.transports.file.filename); }; /** * Resets log file. * * @function */ logger.resetFile = () =&gt; { var logPath = logger.getFile(); if (!logPath) return; fs.unlinkSync(logPath); logger.setFile(logPath); }; }; /* Config */ if (global.__glaceConfig) { module.exports.config = global.__glaceConfig; } else { /** * @prop {object} config - `GlaceJS` config. */ var config = module.exports.config = global.__glaceConfig = {}; var argsConfig = {}; var argsConfigPath = path.resolve(cwd, (argv.c || argv.config || &quot;config.json&quot;)); if (fs.existsSync(argsConfigPath)) { argsConfig = loadJson(argsConfigPath); for (var key in argsConfig) { var val = argsConfig[key]; argsConfig[_.camelCase(key)] = val; }; }; _.mergeWith(argsConfig, argv, (objVal, srcVal) =&gt; srcVal ? srcVal : objVal); config.args = argsConfig; }; /** * Wraps function inside other functions. * * @function * @arg {function[]} wrappers - List of functions which will wrap target. * @arg {function} target - Target function which will be wrapped. * @return {function} - Wrapping function. */ module.exports.wrap = (wrappers, target) =&gt; { _.clone(wrappers).reverse().forEach(wrapper =&gt; { target = (target =&gt; () =&gt; wrapper(target))(target); }); return target; }; /** * Helper to kill processes by name. * * @async * @function * @arg {string} procName - Process name or chunk of name. * @return {Promise&lt;void&gt;} */ module.exports.killProcs = procName =&gt; { return findProcess(&quot;name&quot;, procName).then(procList =&gt; { return procList.forEach(proc =&gt; { try { process.kill(proc.pid, &quot;SIGTERM&quot;); logger.debug(`Kill ${procName} with PID ${proc.pid}`); } catch (e) { if (e.message !== &quot;kill ESRCH&quot;) throw e; logger.error(`Can't kill ${procName} with PID ${proc.pid}`, `because it doesn't exist`); }; }); }); }; × Search results Close "},"modules.list.html":{"id":"modules.list.html","title":"Modules","body":" GlaseJS Utils Modules index Modules × Search results Close "},"index.html":{"id":"index.html","title":"Index","body":" GlaseJS Utils Modules index GlaceJS utilities. × Search results Close "},"module-index.html":{"id":"module-index.html","title":"Module: index","body":" GlaseJS Utils Modules index Module: index GlaceJS utils. Source: index.js, line 2 Members &lt;static&gt; hostname Properties: Name Type Description hostname string Machine host name. Source: index.js, line 22 &lt;inner&gt; config Properties: Name Type Description config object GlaceJS config. Source: index.js, line 315 &lt;inner&gt; cwd Properties: Name Type Description cwd string Current work directory. Source: index.js, line 238 &lt;inner&gt; logger Properties: Name Type Description logger Logger GlaceJS logger. Source: index.js, line 263 Methods &lt;static&gt; capitalize(string) Capitalizes first letter of string. Doesn&quot;t influence to case of other letters. Parameters: Name Type Description string string string to capitalize Source: index.js, line 44 Returns: capitalized string Type string &lt;static&gt; defVal(values) Gets default value for variable among passed listed values. Parameters: Name Type Argument Description values * &lt;repeatable&gt; variable values Source: index.js, line 30 Returns: last specified value or null if last is undefined. Type * &lt;static&gt; exit(source) Exits process with error printing. Parameters: Name Type Description source string Source of fatal error. Source: index.js, line 231 Returns: Function with takes error to print and exits process. Type function &lt;static&gt; filesByDate(dir [, opts]) Sorts files by date in folder. Parameters: Name Type Argument Description dir string Path to directory. opts object &lt;optional&gt; Options. Properties Name Type Argument Default Description desc boolean &lt;optional&gt; false Flag to reverse order. Source: index.js, line 123 Returns: Sequence of files sorted by date Type Array.&lt;string&gt; &lt;static&gt; filesByOrder(dir [, opts]) Files sorted by order. Parameters: Name Type Argument Description dir string Path to directory. opts object &lt;optional&gt; Options. Properties Name Type Argument Default Description desc boolean &lt;optional&gt; false Flag to reverse order. Source: index.js, line 153 Returns: Sequence of files sorted by order. Type Array.&lt;string&gt; &lt;static&gt; getReqKey(req) Helper to generate request key for storage. Parameters: Name Type Description req Request Client request. Source: index.js, line 113 Returns: Request key according to its method, host, url. Type string &lt;async, static&gt; killProcs(procName) Helper to kill processes by name. Parameters: Name Type Description procName string Process name or chunk of name. Source: index.js, line 353 Returns: Type Promise.&lt;void&gt; &lt;static&gt; mkpath(paths) Composes file path from segments. If folder of file is absent, it will be created. Parameters: Name Type Argument Description paths string &lt;repeatable&gt; A sequence of paths or path segments. Source: index.js, line 100 Returns: Composed path. Type string &lt;static&gt; sleep(timeout [, blocking]) Makes delay (sleep) during code execution. Parameters: Name Type Argument Default Description timeout number Time to sleep, ms. blocking boolean &lt;optional&gt; false Flag whether sleep should be block code execution. Source: index.js, line 79 Returns: If sleep isn't blocking. Type Promise If sleep is blocking. Type undefined &lt;static&gt; subFolders(dir [, opts]) Gets subfolders of directory. Parameters: Name Type Argument Description dir string Path to directory. opts object &lt;optional&gt; Options. Properties Name Type Argument Default Description nameOnly boolean &lt;optional&gt; false Gets only folder names. By default, full paths. Source: index.js, line 183 Returns: Sequence of results. Type Array.&lt;string&gt; &lt;static&gt; switchColor( [opts]) Returns function which switches message color. Parameters: Name Type Argument Description opts object &lt;optional&gt; Options. Properties Name Type Argument Default Description c1 string &lt;optional&gt; magenta Color #1. c2 string &lt;optional&gt; cyan Color #2. Source: index.js, line 211 Returns: Function to switch color of passed text in terminal. Type function &lt;static&gt; wrap(wrappers, target) Wraps function inside other functions. Parameters: Name Type Description wrappers Array.&lt;function()&gt; List of functions which will wrap target. target function Target function which will be wrapped. Source: index.js, line 339 Returns: Wrapping function. Type function &lt;inner&gt; clearEmptyFolders(folder) Clears empty folders recursive. Parameters: Name Type Description folder string path to root folder Source: index.js, line 53 &lt;inner&gt; loadJson(name) Loads json file which may have comments. Parameters: Name Type Description name string Name of JSON file. Source: index.js, line 247 Throws: If JSON file isn't parsable. Type Error Returns: Object. Type object × Search results Close "}}
    </script>

    <script type="text/javascript">
        $(document).ready(function() {
            Searcher.init();
        });

        $(window).on("message", function(msg) {
            var msgData = msg.originalEvent.data;

            if (msgData.msgid != "docstrap.quicksearch.start") {
                return;
            }

            var results = Searcher.search(msgData.searchTerms);

            window.parent.postMessage({"results": results, "msgid": "docstrap.quicksearch.done"}, "*");
        });
    </script>
</body>
</html>
